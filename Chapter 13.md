# 并发编程



## 13.1 为什么要并发

并发是一种解耦策略。

### 迷思与误解：

- 并发总能改进性能
- 编写并发程序无须修改设计
- 在采用Web或者EJB容器的时候，理解并发编程并不重要。



## 13.2 挑战



## 13.3 并发防御原则

### 13.3.1 单一权责原则

### 13.3.2 推论：限制数据作用域

### 13.3.3 推论：使用数据副本

### 13.3.4 推论：线程应尽可能的独立



## 13.4 了解Java库



## 13.5 了解执行模型

| 定义     | 描述                                                         |
| -------- | :----------------------------------------------------------- |
| 限定资源 | 并发环境中有着固定尺寸或者数量的资源。                       |
| 互斥     | 每一时刻仅有一个线程能访问共享数据或资源。                   |
| 线程饥饿 | 一个或一组线程在很长时间内或永久被禁止。                     |
| 死锁     | 两个或多个线程互相等待执行结束。                             |
| 活锁     | 执行次序一致的线程，每个都想要起步，但发现其他线程已经“在路上”。 |

### 13.5.1 生产者-消费者模型

### 13.5.2 读者-作者模型

### 13.5.3 宴席哲学家



## 13.6 警惕同步方法之间的依赖

避免使用一个共享对象的多个方法。

- 基于客户端的锁定
- 基于服务端的锁定
- 适配服务端



## 13.7 保持同步区域微小



## 13.8 很难编写正确的代码

尽早考虑关闭问题，尽早令其工作正常。



## 13.9 测试线程代码

- 将伪失败看做可能的线程问题
- 先使非线程代码工作正常
- 编写可拔插的线程代码
- 编写可调整的线程代码
- 运行多于处理器数量的线程
- 在不用平台上运行
- 调整代码并强迫错误发生

### 13.9.1 将伪失败看做可能的线程问题

不要将系统错误归咎于偶发事件

### 13.9.2 先使非线程代码工作正常

不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可工作。

### 13.9.3 编写可拔插的线程代码

### 13.9.4 编写可调整的线程代码

### 13.9.5 运行多于处理器数量的线程

任务切换越频繁，越可能找到错过临界区导致死锁的代码。

### 13.9.6 在不用平台上运行

### 13.9.7 装配试错代码

### 13.9.8 硬编码

### 13.9.9 自动化

